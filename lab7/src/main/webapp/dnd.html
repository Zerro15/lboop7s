<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>D&D –õ–∏—Å—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ —Å –≤–∏–∑—É–∞–ª—å–Ω–æ–π –±–æ—ë–≤–∫–æ–π</title>
    <link rel="stylesheet" href="assets/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SzlrxWUlpfuzQ+pcUCosxcglQRNAq/DZjVsC0lE0x1r3ZLr3I8aH3V9Wf0R7WkG7rG3f67j6c6Ww5q3P6lz1Kg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body { padding: 16px; }
        h1,h2,h3,h4 { margin: 0; }
        a { color: inherit; }

        .sheet-note {
            margin-top: 8px;
            padding: 10px 12px;
            border: 2px dashed var(--border);
            background: var(--surface);
            color: var(--muted);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 12px;
        }
        .stat-card {
            padding: 12px;
            background: transparent;
            border: 2px solid var(--border);
            display: grid;
            gap: 6px;
        }
        .stat-card.pulse { animation: pulse 0.8s ease; }
        .stat-head { display: flex; flex-direction: column; gap: 2px; }
        .stat-name { font-weight: 800; text-transform: uppercase; }
        .stat-hint { color: var(--muted); font-size: 13px; }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            border: 2px solid var(--border);
        }

        .section-title { display: flex; align-items: center; gap: 8px; text-transform: uppercase; }
        .hp-summary { display: grid; grid-template-columns: repeat(auto-fit,minmax(200px,1fr)); gap: 8px; margin-top: 8px; }
        .metric {
            padding: 10px 12px;
            background: var(--surface);
            border: 2px solid var(--border);
        }

        .battle-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin-top: 14px;
            align-items: stretch;
        }
        .combatant {
            padding: 16px;
            background: transparent;
            border: 2px solid var(--border);
            position: relative;
        }
        .combatant.attacking { animation: attackAnimation .3s ease; }
        .combatant.damaging { animation: damageFlash .5s ease; }
        .combatant.healing { animation: healFlash .5s ease; }
        .combatant-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
        }
        .hp-wrap { margin-top: 10px; }
        .hp-row { display: flex; justify-content: space-between; align-items: center; }
        .hp-bar {
            width: 100%;
            height: 14px;
            background: var(--border);
            overflow: hidden;
            margin-top: 6px;
        }
        .hp-fill {
            height: 100%;
            width: 100%;
            transition: width .5s ease, background .3s ease;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
        }
        .vs {
            display: grid;
            place-items: center;
            font-weight: 900;
            font-size: 18px;
            color: var(--accent);
        }
        .combat-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }
        .stat-pill {
            background: var(--surface);
            border: 2px solid var(--border);
            padding: 8px;
            text-align: center;
            font-weight: 700;
        }

        .progress {
            margin-top: 12px;
            background: transparent;
            border: 2px solid var(--border);
            padding: 12px;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--border);
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            transition: width .4s ease;
        }
        .log {
            margin-top: 12px;
            height: 220px;
            overflow-y: auto;
            padding: 10px;
            border: 2px solid var(--border);
            background: var(--surface);
        }
        .log-entry {
            padding: 8px 10px;
            margin: 6px 0;
            border: 2px solid var(--border);
            border-left: 4px solid var(--accent);
            animation: slideIn .3s ease;
        }
        .log-entry.damage { border-left-color: var(--danger); }
        .log-entry.heal { border-left-color: var(--accent); }
        .log-entry.victory { border-left-color: var(--accent); font-weight: 800; }
        .log-entry.defeat { border-left-color: var(--danger); font-weight: 800; }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            backdrop-filter: blur(3px);
            animation: modalAppear .25s ease;
        }
        .modal[hidden] { display: none !important; }
        .modal-card {
            background: var(--surface);
            padding: 20px;
            width: min(520px, 92vw);
            border: 2px solid var(--border);
        }

        .choice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 12px;
        }
        .choice {
            padding: 12px;
            border: 2px solid var(--border);
            background: transparent;
            cursor: pointer;
        }
        .choice.selected {
            border-color: var(--accent);
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
        @keyframes dice-roll { 0% { transform: rotate(0deg); } 50% { transform: rotate(180deg); } 100% { transform: rotate(360deg); } }
        @keyframes slideIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes modalAppear { from { opacity: 0; transform: scale(.96);} to { opacity: 1; transform: scale(1);} }
        @keyframes damageFlash { 0%,100% { background: transparent;} 50% { background: rgba(214,64,69,0.25);} }
        @keyframes healFlash { 0%,100% { background: transparent;} 50% { background: rgba(94,162,255,0.2);} }
        @keyframes attackAnimation { 0%{transform: translateX(0);}50%{transform: translateX(-6px);}100%{transform: translateX(0);} }

        @media (max-width: 768px) {
            .panel { flex-direction: column; align-items: flex-start; }
            .grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
<div class="layout">
    <header class="panel">
        <div>
            <h1>D&D –õ–∏—Å—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h1>
            <p class="muted">–ù–µ–æ–º–æ—Ä—Ñ–Ω—ã–π –ª–∏—Å—Ç —Å –±–æ—ë–≤–∫–æ–π –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–π.</p>
        </div>
        <div class="actions">
            <button id="newCharacterBtn" class="ghost" type="button">üÜï –ù–æ–≤—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂</button>
            <button id="themeToggle" class="ghost" type="button"><i class="fa-regular fa-moon"></i> –¢—ë–º–Ω–∞—è —Ç–µ–º–∞</button>
            <a class="button ghost" href="/index.html">–ì–ª–∞–≤–Ω–∞—è</a>
        </div>
    </header>

    <section class="card">
        <div class="section-title">
            <h2>–õ–∏—Å—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
            <span class="badge">–£—Ä–æ–≤–µ–Ω—å <span id="levelValue">1</span></span>
        </div>
        <div class="grid">
            <label>–ò–º—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞<input id="charName" type="text" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä, –ê–ª–∏—Å–∞"></label>
            <label>–ü—Ä–µ–¥—ã—Å—Ç–æ—Ä–∏—è
                <select id="charBackground">
                    <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥—ã—Å—Ç–æ—Ä–∏—é</option>
                    <option>–ë—ã–≤—à–∏–π —Å–ø–æ—Ä—Ç—Å–º–µ–Ω</option>
                    <option>–õ—é–±–∏—Ç–µ–ª—å –∏–≥—Ä</option>
                    <option>–ú–µ—Å—Ç–Ω—ã–π –∞–∫—Ç–∏–≤–∏—Å—Ç</option>
                </select>
            </label>
            <label>–ö–ª–∞—Å—Å
                <select id="charClass">
                    <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞—Å—Å</option>
                    <option value="leader">–°—Ç–∞—Ä–æ—Å—Ç–∞</option>
                    <option value="nerd">–£–º–Ω–∏–∫</option>
                    <option value="vibe">–í–∞–π–±–∫–æ–¥–µ—Ä</option>
                </select>
            </label>
            <label>–ù–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã<input id="charGroup" type="text" placeholder="–ò–°–ü-204"></label>
        </div>
        <div class="sheet-note" id="classDetails">–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞—Å—Å, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –±–æ–Ω—É—Å—ã.</div>
        <div class="sheet-note">–í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã. –ë—Ä–æ—Å—å—Ç–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–≤–æ–±–æ–¥–Ω—ã–π –±—Ä–æ—Å–æ–∫.</div>
        <div class="stats-grid" id="statsGrid">
            <!-- cards injected -->
        </div>
        <div class="actions">
            <button id="rollAll">üé≤ –ë—Ä–æ—Å–∏—Ç—å –≤—Å–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏</button>
            <button id="saveCharacter" class="ghost">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</button>
        </div>
        <div class="grid">
            <div class="class-callout stat-card">
                <div class="stat-head">
                    <div class="stat-name">–°–≤–æ–±–æ–¥–Ω—ã–π –±—Ä–æ—Å–æ–∫ d20</div>
                    <div class="stat-hint">–°–¥–µ–ª–∞–π—Ç–µ –±—Ä–æ—Å–æ–∫ –∏ –Ω–∞–∑–Ω–∞—á—å—Ç–µ –≤ –Ω—É–∂–Ω—É—é —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É.</div>
                </div>
                <div class="actions" style="margin-top:8px;">
                    <button id="freeRoll" type="button">üé≤ –°–≤–æ–±–æ–¥–Ω—ã–π –±—Ä–æ—Å–æ–∫</button>
                    <div id="freeRollValue" class="badge">‚Äî</div>
                </div>
                <label style="margin-top:8px;">–ù–∞–∑–Ω–∞—á–∏—Ç—å –≤ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É
                    <select id="assignSelect">
                        <option value="">–ù–µ –≤—ã–±—Ä–∞–Ω–æ</option>
                        <option value="strength">–°–∏–ª–∞</option>
                        <option value="dexterity">–õ–æ–≤–∫–æ—Å—Ç—å</option>
                        <option value="constitution">–í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å</option>
                        <option value="intelligence">–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç</option>
                        <option value="charisma">–•–∞—Ä–∏–∑–º–∞</option>
                        <option value="luck">–£–¥–∞—á–∞</option>
                    </select>
                </label>
                <div class="actions" style="margin-top:8px;">
                    <button id="assignRoll" class="ghost">–ù–∞–∑–Ω–∞—á–∏—Ç—å</button>
                </div>
            </div>
            <div class="class-callout stat-card">
                <div class="stat-head">
                    <div class="stat-name">–ë–æ–µ–≤—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏</div>
                </div>
                <div class="hp-summary">
                    <div class="metric">
                        <div class="stat-name">HP (–ª–∏—Å—Ç)</div>
                        <div id="hpSheet">‚Äî</div>
                    </div>
                    <div class="metric">
                        <div class="stat-name">HP (–±–æ–π)</div>
                        <div id="hpBattle">‚Äî</div>
                    </div>
                </div>
                <div class="hp-summary">
                    <div class="metric">
                        <div class="stat-name">–£—Ä–æ–Ω (–ª–æ–≥–∏–∫–∞)</div>
                        <div id="damageIntValue">‚Äî</div>
                    </div>
                    <div class="metric">
                        <div class="stat-name">–£—Ä–æ–Ω (—Ö–∞—Ä–∏–∑–º–∞)</div>
                        <div id="damageChaValue">‚Äî</div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="card" id="battleSection">
        <div class="section-title">
            <h2>–ë–æ—ë–≤–∫–∞ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–π</h2>
            <span class="badge">–ü—Ä–æ–≥—Ä–µ—Å—Å <span id="progressText">0 / 8</span></span>
        </div>
        <div class="battle-container">
            <div class="combatant player" id="playerBox">
                <div class="combatant-header">
                    <h3 id="playerNameDisplay">–ò–≥—Ä–æ–∫</h3>
                    <span class="badge">Lvl <span id="combatLevel">1</span></span>
                </div>
                <div class="hp-wrap">
                    <div class="hp-row"><span>‚ù§Ô∏è HP</span><span id="playerHPText">0/0</span></div>
                    <div class="hp-bar"><div class="hp-fill" id="playerHPFill"></div></div>
                </div>
                <div class="combat-stats">
                    <div class="stat-pill">‚öîÔ∏è –ê—Ç–∞–∫–∞: <span id="playerAttack">0</span></div>
                    <div class="stat-pill">üõ°Ô∏è –ó–∞—â–∏—Ç–∞: <span id="playerDefense">0</span></div>
                    <div class="stat-pill">üçÄ –£–¥–∞—á–∞: <span id="playerLuck">0</span></div>
                </div>
            </div>
            <div class="vs"><span>VS</span></div>
            <div class="combatant enemy" id="enemyBox">
                <div class="combatant-header">
                    <h3 id="enemyNameDisplay">–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫</h3>
                    <span class="badge" id="enemyDifficulty">‚Äî</span>
                </div>
                <div class="hp-wrap">
                    <div class="hp-row"><span>üíÄ HP</span><span id="enemyHPText">0/0</span></div>
                    <div class="hp-bar"><div class="hp-fill" id="enemyHPFill"></div></div>
                </div>
                <div class="combat-stats">
                    <div class="stat-pill">‚öîÔ∏è –£—Ä–æ–Ω: <span id="enemyDamage">‚Äî</span></div>
                    <div class="stat-pill">üõ°Ô∏è –ó–∞—â–∏—Ç–∞: <span id="enemyDefense">‚Äî</span></div>
                    <div class="stat-pill">‚≠ê –ù–∞–≥—Ä–∞–¥–∞: <span id="enemyReward">‚Äî</span></div>
                </div>
            </div>
        </div>
        <div class="progress">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                <span>–ü—Ä–æ–≥—Ä–µ—Å—Å –ª–∞–±</span><span id="labProgressText">0/8</span>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="labProgressFill"></div></div>
            <div style="display:flex;gap:12px;flex-wrap:wrap;margin-top:8px;">
                <span>XP: <strong id="progressXP">0</strong></span>
                <span>–û—Ç–¥—ã—Ö–æ–≤: <strong id="restCount">3</strong></span>
            </div>
        </div>
        <div class="actions" style="margin-top:10px; flex-wrap: wrap;">
            <button id="battleStart" class="ghost">–ù–∞—á–∞—Ç—å / –°–ª–µ–¥—É—é—â–∞—è –ª–∞–±–∞</button>
            <button id="battleAttack">‚öîÔ∏è –ê—Ç–∞–∫–æ–≤–∞—Ç—å</button>
            <button id="useAbility" class="ghost">‚ú® –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å</button>
            <button id="battleRest" class="ghost">üí§ –û—Ç–¥–æ—Ö–Ω—É—Ç—å</button>
        </div>
        <div class="log" id="battleLog"></div>
    </section>
</div>

<div class="modal" id="victoryModal" hidden>
    <div class="modal-card">
        <h3>üéâ –ü–æ–±–µ–¥–∞!</h3>
        <p>–í—ã –æ–¥–æ–ª–µ–ª–∏: <strong id="victoryName"></strong></p>
        <p>–ü–æ–ª—É—á–µ–Ω–æ <strong id="victoryXP">0</strong> XP. HP –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã.</p>
        <div class="actions">
            <button id="nextLabBtn">–°–ª–µ–¥—É—é—â–∞—è –ª–∞–±–∞</button>
        </div>
    </div>
</div>

<div class="modal" id="defeatModal" hidden>
    <div class="modal-card">
        <h3>üíÄ –ü–æ—Ä–∞–∂–µ–Ω–∏–µ</h3>
        <p>–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–∂ –ø–∞–ª. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–≥–æ –≥–µ—Ä–æ—è –∏ –Ω–∞—á–Ω–∏—Ç–µ –ø—É—Ç—å –∑–∞–Ω–æ–≤–æ.</p>
        <div class="actions">
            <button id="openResetBtn">–û—Ç–∫—Ä—ã—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</button>
        </div>
    </div>
</div>

<div class="modal" id="levelModal" hidden>
    <div class="modal-card">
        <h3>üéä –£—Ä–æ–≤–µ–Ω—å –ø–æ–≤—ã—à–µ–Ω!</h3>
        <p>–í—Å–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ +1. –í—ã–±–µ—Ä–∏—Ç–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É –¥–ª—è +2:</p>
        <div class="choice-grid" id="levelChoices"></div>
        <div class="actions" style="margin-top:10px;">
            <button id="confirmLevelUp" disabled>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å</button>
        </div>
    </div>
</div>

<div class="modal" id="resetModal" hidden>
    <div class="modal-card">
        <h3 id="resetTitle">üÜï –ù–æ–≤—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂</h3>
        <p id="resetMessage">–°–±—Ä–æ—Å—å—Ç–µ —Ç–µ–∫—É—â–µ–≥–æ –≥–µ—Ä–æ—è –∏ –Ω–∞—á–Ω–∏—Ç–µ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–π —Å–Ω–∞—á–∞–ª–∞.</p>
        <div class="actions" style="margin-top:10px;">
            <button id="confirmReset">–°–æ–∑–¥–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
            <button id="cancelReset" class="ghost">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<script>
    (() => {
        // ---------- State ----------
        const state = {
            level: 1,
            xp: 0,
            rests: 3,
            stats: {
                strength: { base: null, total: null },
                dexterity: { base: null, total: null },
                constitution: { base: null, total: null },
                intelligence: { base: null, total: null },
                charisma: { base: null, total: null },
                luck: { base: null, total: null },
            },
            classId: '',
            freeRoll: null,
            playerHp: null,
            enemy: null,
            enemyIndex: 0,
            abilityCooldown: 0,
            buffTurns: 0,
            buffs: { luck: 0, intelligence: 0 },
            enemyDebuff: 0,
        };

        const STORAGE_KEY = 'neo-dnd-sheet';
        const THEME_KEY = 'lab7Theme';

        const classMap = {
            leader: { name: '–°—Ç–∞—Ä–æ—Å—Ç–∞', mods: { charisma: 2, luck: 1 }, ability: '–£–¥–∞—á–∞ —Å—Ç–∞—Ä–æ—Å—Ç—ã' },
            nerd: { name: '–£–º–Ω–∏–∫', mods: { intelligence: 2, luck: -1, charisma: -1 }, ability: '–°–∫–∞–Ω —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π' },
            vibe: { name: '–í–∞–π–±–∫–æ–¥–µ—Ä', mods: { dexterity: 2, luck: 2 }, ability: '–ö–æ–¥ —Ä–∞–∑—É–º–∞' },
        };

        const enemies = [
            { name: 'Hello World', hp: 30, ac: 10, dmg: '1d6+1', xp: 50 },
            { name: '–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä', hp: 40, ac: 12, dmg: '1d6+2', xp: 75 },
            { name: '–ú–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö', hp: 50, ac: 14, dmg: '1d8+2', xp: 100 },
            { name: '–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö', hp: 60, ac: 16, dmg: '1d8+3', xp: 125 },
            { name: '–í–µ–±-—Å–µ—Ä–≤–µ—Ä', hp: 70, ac: 18, dmg: '1d10+4', xp: 150 },
            { name: '–ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—å', hp: 80, ac: 20, dmg: '1d10+5', xp: 175 },
            { name: '–ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç', hp: 90, ac: 22, dmg: '1d12+6', xp: 200 },
            { name: '–≠–∫–∑–∞–º–µ–Ω–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–æ–º–∏—Å—Å–∏—è', hp: 150, ac: 24, dmg: '2d8+8', xp: 500 },
        ];

        const statList = [
            { key: 'strength', label: '–°–∏–ª–∞', hint: 'üí™ –£—Ä–æ–Ω –±–ª–∏–∂–Ω–µ–≥–æ –±–æ—è' },
            { key: 'dexterity', label: '–õ–æ–≤–∫–æ—Å—Ç—å', hint: 'üèÉ –ó–∞—â–∏—Ç–∞/—Ç–æ—á–Ω–æ—Å—Ç—å' },
            { key: 'constitution', label: '–í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å', hint: '‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤—å–µ' },
            { key: 'intelligence', label: '–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç', hint: 'üß† –£–º–Ω–∏–∫ —É—Ä–æ–Ω' },
            { key: 'charisma', label: '–•–∞—Ä–∏–∑–º–∞', hint: 'üòé –°—Ç–∞—Ä–æ—Å—Ç–∞ —É—Ä–æ–Ω' },
            { key: 'luck', label: '–£–¥–∞—á–∞', hint: 'üçÄ –ë–æ–Ω—É—Å –∫ –∞—Ç–∞–∫–∞–º' },
        ];

        const elements = {
            levelValue: document.getElementById('levelValue'),
            classDetails: document.getElementById('classDetails'),
            statsGrid: document.getElementById('statsGrid'),
            rollAll: document.getElementById('rollAll'),
            saveCharacter: document.getElementById('saveCharacter'),
            freeRoll: document.getElementById('freeRoll'),
            freeRollValue: document.getElementById('freeRollValue'),
            assignSelect: document.getElementById('assignSelect'),
            assignRoll: document.getElementById('assignRoll'),
            hpSheet: document.getElementById('hpSheet'),
            hpBattle: document.getElementById('hpBattle'),
            damageIntValue: document.getElementById('damageIntValue'),
            damageChaValue: document.getElementById('damageChaValue'),
            playerNameDisplay: document.getElementById('playerNameDisplay'),
            combatLevel: document.getElementById('combatLevel'),
            playerAttack: document.getElementById('playerAttack'),
            playerDefense: document.getElementById('playerDefense'),
            playerLuck: document.getElementById('playerLuck'),
            playerHPText: document.getElementById('playerHPText'),
            playerHPFill: document.getElementById('playerHPFill'),
            enemyNameDisplay: document.getElementById('enemyNameDisplay'),
            enemyDifficulty: document.getElementById('enemyDifficulty'),
            enemyHPText: document.getElementById('enemyHPText'),
            enemyHPFill: document.getElementById('enemyHPFill'),
            enemyDamage: document.getElementById('enemyDamage'),
            enemyDefense: document.getElementById('enemyDefense'),
            enemyReward: document.getElementById('enemyReward'),
            labProgressFill: document.getElementById('labProgressFill'),
            labProgressText: document.getElementById('labProgressText'),
            progressXP: document.getElementById('progressXP'),
            progressText: document.getElementById('progressText'),
            restCount: document.getElementById('restCount'),
            battleStart: document.getElementById('battleStart'),
            battleAttack: document.getElementById('battleAttack'),
            useAbility: document.getElementById('useAbility'),
            battleRest: document.getElementById('battleRest'),
            battleLog: document.getElementById('battleLog'),
            victoryModal: document.getElementById('victoryModal'),
            defeatModal: document.getElementById('defeatModal'),
            levelModal: document.getElementById('levelModal'),
            victoryName: document.getElementById('victoryName'),
            victoryXP: document.getElementById('victoryXP'),
            nextLabBtn: document.getElementById('nextLabBtn'),
            confirmLevelUp: document.getElementById('confirmLevelUp'),
            levelChoices: document.getElementById('levelChoices'),
            progressLevelBadge: document.getElementById('progressLevel'),
            themeToggle: document.getElementById('themeToggle'),
            battleSection: document.getElementById('battleSection'),
            newCharacterBtn: document.getElementById('newCharacterBtn'),
            resetModal: document.getElementById('resetModal'),
            confirmReset: document.getElementById('confirmReset'),
            cancelReset: document.getElementById('cancelReset'),
            resetTitle: document.getElementById('resetTitle'),
            resetMessage: document.getElementById('resetMessage'),
            openResetBtn: document.getElementById('openResetBtn'),
        };

        // ---------- Helpers ----------
        function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function rollD20() { return randInt(1, 20); }

        function rollDiceString(expr) {
            // supports "2d8+3" or "1d6"
            const match = expr.match(/(\d+)d(\d+)(\+(\d+))?/i);
            if (!match) return 0;
            const count = parseInt(match[1], 10);
            const faces = parseInt(match[2], 10);
            const bonus = parseInt(match[4] || '0', 10);
            let total = 0;
            for (let i = 0; i < count; i++) total += randInt(1, faces);
            return total + bonus;
        }

        function classStatKey() {
            if (state.classId === 'leader') return 'charisma';
            if (state.classId === 'nerd') return 'intelligence';
            return 'dexterity';
        }

        function effectiveStat(key) {
            const total = state.stats[key].total || 0;
            const buff = state.buffTurns > 0 ? (state.buffs[key] || 0) : 0;
            return total + buff;
        }

        function updateAbilityButton() {
            const abilityName = classMap[state.classId]?.ability || '–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å';
            if (!elements.useAbility) return;
            const cd = state.abilityCooldown;
            elements.useAbility.textContent = cd > 0 ? `‚ú® ${abilityName} (CD ${cd})` : `‚ú® ${abilityName}`;
            elements.useAbility.disabled = !state.classId || cd > 0;
        }

        // ---------- Rendering ----------
        function renderStatCards() {
            elements.statsGrid.innerHTML = '';
            statList.forEach(({ key, label, hint }) => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.dataset.stat = key;
                card.innerHTML = `
            <div class="stat-head">
              <div class="stat-name">${label}</div>
              <div class="stat-hint">${hint}</div>
            </div>
            <div class="stat-row"><span>–ë–∞–∑–æ–≤–æ–µ</span><span class="stat-base">‚Äî</span></div>
            <div class="stat-row"><span>–ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–ª–∞—Å—Å–∞</span><span class="stat-mod">+0</span></div>
            <div class="stat-row"><span>–ò—Ç–æ–≥</span><span class="stat-total">‚Äî</span></div>
            <button class="mini-roll" data-roll="${key}">üé≤ –ë—Ä–æ—Å–∏—Ç—å d20</button>
          `;
                elements.statsGrid.appendChild(card);
            });
        }

        function classBonus(stat) {
            const info = classMap[state.classId];
            if (!info) return 0;
            return info.mods[stat] || 0;
        }

        function deriveStats() {
            statList.forEach(({ key }) => {
                const base = state.stats[key].base;
                const mod = classBonus(key);
                state.stats[key].total = base === null ? null : base + mod;
            });
            updateDerived();
        }

        function updateDerived() {
            const totals = state.stats;
            const hpSheet = (totals.constitution.total || 0) * 2 + (totals.strength.total || 0);
            const hpBattle = 20 + (totals.constitution.total || 0) * 3;
            elements.hpSheet.textContent = hpSheet || '‚Äî';
            elements.hpBattle.textContent = hpBattle || '‚Äî';

            const intStat = state.stats.intelligence.total === null && state.buffTurns === 0 ? null : effectiveStat('intelligence');
            elements.damageIntValue.textContent = intStat === null ? '‚Äî' :
                `${Math.floor(intStat / 2)} + 1d6`;
            const luckStat = state.stats.luck.total === null && state.buffTurns === 0 ? null : effectiveStat('luck');
            if (state.stats.charisma.total === null || luckStat === null) {
                elements.damageChaValue.textContent = '‚Äî';
            } else {
                const base = Math.floor(state.stats.charisma.total / 2) + Math.floor(luckStat / 4);
                elements.damageChaValue.textContent = `${base} + 1d6`;
            }
            updateBattleUI();
        }

        function renderStatsValues() {
            deriveStats();
            statList.forEach(({ key }) => {
                const card = elements.statsGrid.querySelector(`[data-stat="${key}"]`);
                const baseEl = card.querySelector('.stat-base');
                const modEl = card.querySelector('.stat-mod');
                const totalEl = card.querySelector('.stat-total');
                const base = state.stats[key].base;
                const mod = classBonus(key);
                const total = state.stats[key].total;
                baseEl.textContent = base === null ? '‚Äî' : base;
                modEl.textContent = mod >= 0 ? `+${mod}` : mod;
                totalEl.textContent = total === null ? '‚Äî' : total;
            });
        }

        function setClassDetails() {
            const info = classMap[state.classId];
            if (!info) {
                elements.classDetails.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞—Å—Å, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –±–æ–Ω—É—Å—ã.';
                updateAbilityButton();
                return;
            }
            const mods = Object.entries(info.mods).map(([k,v]) => `${k}: ${v>0?'+':''}${v}`).join(', ');
            elements.classDetails.textContent = `${info.name}. –ë–æ–Ω—É—Å—ã: ${mods}. –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å: ${info.ability}`;
            elements.useAbility.textContent = `‚ú® ${info.ability}`;
            updateAbilityButton();
        }

        // ---------- Storage ----------
        function saveToStorage() {
            const payload = {
                level: state.level,
                xp: state.xp,
                rests: state.rests,
                stats: state.stats,
                classId: state.classId,
                enemyIndex: state.enemyIndex,
                abilityCooldown: state.abilityCooldown,
                buffTurns: state.buffTurns,
                buffs: state.buffs,
                enemyDebuff: state.enemyDebuff,
                playerHp: state.playerHp,
                freeRoll: state.freeRoll,
                name: document.getElementById('charName').value,
                background: document.getElementById('charBackground').value,
                group: document.getElementById('charGroup').value,
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        }

        function loadFromStorage() {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return;
            try {
                const data = JSON.parse(raw);
                state.level = data.level || 1;
                state.xp = data.xp || 0;
                state.rests = data.rests ?? 3;
                state.stats = data.stats || state.stats;
                state.classId = data.classId || '';
                state.enemyIndex = data.enemyIndex || 0;
                state.abilityCooldown = data.abilityCooldown || 0;
                state.buffTurns = data.buffTurns || 0;
                state.buffs = data.buffs || { luck: 0, intelligence: 0 };
                state.enemyDebuff = data.enemyDebuff || 0;
                state.playerHp = data.playerHp || null;
                state.freeRoll = data.freeRoll ?? null;
                document.getElementById('charName').value = data.name || '';
                document.getElementById('charBackground').value = data.background || '';
                document.getElementById('charGroup').value = data.group || '';
                document.getElementById('charClass').value = state.classId;
            } catch (e) { console.warn('load failed', e); }
        }

        // ---------- Character ----------
        function rollStat(key) {
            const value = rollD20();
            state.stats[key].base = value;
            const card = elements.statsGrid.querySelector(`[data-stat="${key}"]`);
            card.classList.add('pulse');
            setTimeout(() => card.classList.remove('pulse'), 500);
            renderStatsValues();
            log(`üé≤ ${key} = ${value}`, 'info');
            saveToStorage();
        }

        function rollAll() {
            statList.forEach(({ key }) => rollStat(key));
        }

        function assignFree() {
            if (state.freeRoll === null) {
                log('–°–Ω–∞—á–∞–ª–∞ —Å–¥–µ–ª–∞–π—Ç–µ —Å–≤–æ–±–æ–¥–Ω—ã–π –±—Ä–æ—Å–æ–∫.', 'info');
                return;
            }
            const target = elements.assignSelect.value;
            if (!target) return;
            state.stats[target].base = state.freeRoll;
            state.freeRoll = null;
            elements.freeRollValue.textContent = '‚Äî';
            renderStatsValues();
            saveToStorage();
        }

        function validateForm() {
            if (!document.getElementById('charName').value.trim()) return false;
            if (!document.getElementById('charBackground').value) return false;
            if (!document.getElementById('charClass').value) return false;
            if (!document.getElementById('charGroup').value.trim()) return false;
            const unrolled = statList.some(({ key }) => state.stats[key].base === null);
            return !unrolled;
        }

        function resetCharacter(logReset = true) {
            state.level = 1;
            state.xp = 0;
            state.rests = 3;
            state.classId = '';
            state.enemy = null;
            state.enemyIndex = 0;
            state.playerHp = null;
            state.freeRoll = null;
            state.enemyDebuff = 0;
            state.abilityCooldown = 0;
            state.buffTurns = 0;
            state.buffs = { luck: 0, intelligence: 0 };
            statList.forEach(({ key }) => state.stats[key] = { base: null, total: null });
            document.getElementById('charName').value = '';
            document.getElementById('charBackground').value = '';
            document.getElementById('charClass').value = '';
            document.getElementById('charGroup').value = '';
            elements.freeRollValue.textContent = '‚Äî';
            elements.assignSelect.value = '';
            elements.classDetails.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞—Å—Å, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –±–æ–Ω—É—Å—ã.';
            elements.victoryModal.hidden = true;
            elements.levelModal.hidden = true;
            elements.defeatModal.hidden = true;
            elements.resetModal.hidden = true;
            localStorage.removeItem(STORAGE_KEY);
            renderStatsValues();
            updateAbilityButton();
            updateBattleUI();
            if (elements.battleLog) elements.battleLog.innerHTML = '';
            if (logReset) log('–ü–µ—Ä—Å–æ–Ω–∞–∂ —Å–±—Ä–æ—à–µ–Ω. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ª–∏—Å—Ç –∑–∞–Ω–æ–≤–æ.', 'info');
        }

        function openResetModal(fromDefeat = false) {
            if (fromDefeat) {
                elements.resetTitle.textContent = '–ü–æ—Ä–∞–∂–µ–Ω–∏–µ ‚Äî –Ω–æ–≤—ã–π –≥–µ—Ä–æ–π';
                elements.resetMessage.textContent = '–ü—Ä–æ–≥—Ä–µ—Å—Å –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–π —Å–±—Ä–æ—à–µ–Ω. –ù–∞—á–Ω–∏—Ç–µ —Å –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è.';
            } else {
                elements.resetTitle.textContent = '–ù–æ–≤—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂';
                elements.resetMessage.textContent = '–í—Å–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å –±—É–¥—É—Ç –æ—á–∏—â–µ–Ω—ã.';
            }
            elements.resetModal.hidden = false;
        }

        // ---------- Battle ----------
        function deriveCombat() {
            const mainKey = classStatKey();
            const mainStat = effectiveStat(mainKey);
            const luck = effectiveStat('luck');
            const dex = effectiveStat('dexterity');
            const con = state.stats.constitution.total || 0;
            const maxHp = 20 + con * 3;
            const attackBonus = Math.floor(mainStat / 4) + Math.floor(luck / 6);
            const rollLuck = Math.floor(luck / 3);
            const baseDamageBonus = Math.floor(mainStat / 3);
            const ac = 10 + Math.floor(dex / 4);
            return { maxHp, attackBonus, rollLuck, baseDamageBonus, ac, mainStat, luck };
        }

        function ensureEnemy() {
            if (state.enemy && state.enemy.hp > 0) return state.enemy;
            const enemy = enemies[state.enemyIndex];
            if (!enemy) return null;
            state.enemy = {
                ...enemy,
                hp: enemy.hp,
                maxHp: enemy.hp,
                ac: enemy.ac,
            };
            return state.enemy;
        }

        function updateBattleUI() {
            elements.levelValue.textContent = state.level;
            elements.combatLevel.textContent = state.level;
            elements.progressText.textContent = `${state.enemyIndex} / ${enemies.length}`;
            elements.progressXP.textContent = state.xp;
            elements.restCount.textContent = state.rests;
            const playerName = document.getElementById('charName').value || '–ò–≥—Ä–æ–∫';
            elements.playerNameDisplay.textContent = playerName;

            const derived = deriveCombat();
            const currentEnemy = state.enemy || enemies[state.enemyIndex];
            if (state.playerHp === null) state.playerHp = derived.maxHp;
            const hpPercent = Math.max(0, Math.min(100, (state.playerHp / derived.maxHp) * 100));
            elements.playerHPText.textContent = `${state.playerHp}/${derived.maxHp}`;
            elements.playerHPFill.style.width = `${hpPercent}%`;
            elements.playerHPFill.style.background = hpPercent < 30 ? 'linear-gradient(90deg,#ff5e57,#ff9f0a)' :
                hpPercent < 60 ? 'linear-gradient(90deg,#ff9f0a,#ffd60a)' : 'linear-gradient(90deg,#34c759,#a0f35a)';
            elements.playerAttack.textContent = derived.attackBonus;
            elements.playerDefense.textContent = derived.ac;
            elements.playerLuck.textContent = derived.rollLuck;

            if (currentEnemy) {
                elements.enemyNameDisplay.textContent = currentEnemy.name;
                const ep = state.enemy ? (state.enemy.hp / state.enemy.maxHp) * 100 : 100;
                const ePercent = Math.max(0, Math.min(100, ep));
                elements.enemyHPText.textContent = state.enemy ? `${state.enemy.hp}/${state.enemy.maxHp}` : `${currentEnemy.hp}/${currentEnemy.hp}`;
                elements.enemyHPFill.style.width = `${ePercent}%`;
                elements.enemyHPFill.style.background = ePercent < 30 ? 'linear-gradient(90deg,#ff5e57,#ff9f0a)' :
                    ePercent < 60 ? 'linear-gradient(90deg,#ff9f0a,#ffd60a)' : 'linear-gradient(90deg,#34c759,#a0f35a)';
                elements.enemyDamage.textContent = currentEnemy.dmg;
                elements.enemyDefense.textContent = (state.enemy?.ac ?? currentEnemy.ac);
                elements.enemyReward.textContent = `${currentEnemy.xp} XP`;
                const stars = '‚òÖ'.repeat(Math.min(5, state.enemyIndex + 1)) + '‚òÜ'.repeat(Math.max(0, 5 - state.enemyIndex - 1));
                elements.enemyDifficulty.textContent = stars;
            } else {
                elements.enemyNameDisplay.textContent = '–ü—Ä–æ–π–¥–µ–Ω–æ –≤—Å–µ';
            }

            const progress = (state.enemyIndex / enemies.length) * 100;
            elements.labProgressFill.style.width = `${progress}%`;
            elements.labProgressText.textContent = `${state.enemyIndex}/${enemies.length}`;
            updateAbilityButton();
        }

        function log(message, type = 'info') {
            if (!elements.battleLog) return;
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            elements.battleLog.appendChild(entry);
            elements.battleLog.scrollTop = elements.battleLog.scrollHeight;
        }

        function consumeBuffTurn() {
            if (state.buffTurns > 0) {
                state.buffTurns -= 1;
                if (state.buffTurns === 0) state.buffs = { luck: 0, intelligence: 0 };
            }
        }

        function advanceTurn() {
            consumeBuffTurn();
            if (state.abilityCooldown > 0) state.abilityCooldown -= 1;
            updateAbilityButton();
        }

        function playerAttack() {
            const enemy = ensureEnemy();
            if (!enemy) { log('–í—Å–µ –ª–∞–±—ã –ø—Ä–æ–π–¥–µ–Ω—ã!', 'victory'); return; }
            if (!validateForm()) { log('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ª–∏—Å—Ç –∏ –±—Ä–æ—Å—å—Ç–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏.', 'info'); return; }
            const derived = deriveCombat();
            const roll = rollD20();
            const attackTotal = roll + derived.attackBonus + derived.rollLuck;
            const enemyAc = enemy.ac - state.enemyDebuff;
            if (roll === 20) log('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —É—Å–ø–µ—Ö!', 'victory');
            if (attackTotal >= enemyAc) {
                const damage = rollDiceString('1d6') + derived.baseDamageBonus;
                enemy.hp = Math.max(0, enemy.hp - damage);
                log(`–í—ã –∞—Ç–∞–∫—É–µ—Ç–µ (${roll}+${derived.attackBonus}+${derived.rollLuck}) ‚â• ${enemyAc}. –£—Ä–æ–Ω: ${damage}.`, 'damage');
                if (enemy.hp <= 0) {
                    handleVictory(enemy);
                    return;
                }
            } else {
                log(`–ü—Ä–æ–º–∞—Ö (${attackTotal} < ${enemyAc}).`, 'info');
            }
            enemyAttack();
            state.enemyDebuff = 0;
            advanceTurn();
            saveToStorage();
            updateBattleUI();
        }

        function enemyAttack() {
            const enemy = state.enemy;
            const derived = deriveCombat();
            const roll = rollD20();
            const hit = roll + 2 >= derived.ac;
            if (hit) {
                const dmg = rollDiceString(enemy.dmg);
                state.playerHp = Math.max(0, state.playerHp - dmg);
                log(`${enemy.name} –±—å—ë—Ç (${roll+2} –ø—Ä–æ—Ç–∏–≤ ${derived.ac}) –Ω–∞ ${dmg} —É—Ä–æ–Ω–∞.`, 'damage');
                if (state.playerHp <= 0) {
                    handleDefeat();
                }
            } else {
                log(`${enemy.name} –ø—Ä–æ–º–∞—Ö–∏–≤–∞–µ—Ç—Å—è (${roll+2} < ${derived.ac}).`, 'info');
            }
        }

        function handleVictory(enemy) {
            state.xp += enemy.xp;
            log(`–ü–æ–±–µ–¥–∞ –Ω–∞–¥ ${enemy.name}! +${enemy.xp} XP`, 'victory');
            elements.victoryName.textContent = enemy.name;
            elements.victoryXP.textContent = enemy.xp;
            elements.victoryModal.hidden = false;
            state.enemy = null;
            state.enemyIndex = Math.min(enemies.length, state.enemyIndex + 1);
            const derived = deriveCombat();
            state.playerHp = derived.maxHp;
            state.buffTurns = 0;
            state.buffs = { luck: 0, intelligence: 0 };
            maybeLevelUp();
            advanceTurn();
            saveToStorage();
            updateBattleUI();
        }

        function handleDefeat() {
            log('–í—ã –ø–∞–ª–∏ –≤ –±–æ—é.', 'defeat');
            resetCharacter(false);
            openResetModal(true);
        }

        function restPlayer() {
            if (state.rests <= 0) { log('–û—Ç–¥—ã—Ö–æ–≤ –±–æ–ª—å—à–µ –Ω–µ—Ç.', 'info'); return; }
            state.rests -= 1;
            state.playerHp = deriveCombat().maxHp;
            log('–û—Ç–¥—ã—Ö –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª HP.', 'heal');
            advanceTurn();
            saveToStorage();
            updateBattleUI();
        }

        function useAbility() {
            if (!state.classId) { log('–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∞—Å—Å.', 'info'); return; }
            if (!validateForm()) { log('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ª–∏—Å—Ç –∏ –±—Ä–æ—Å—å—Ç–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏.', 'info'); return; }
            if (state.abilityCooldown > 0) {
                log(`–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–∞ —á–µ—Ä–µ–∑ ${state.abilityCooldown} —Ö–æ–¥–∞(–æ–≤).`, 'info');
                return;
            }
            const cls = state.classId;
            state.buffs = { luck: 0, intelligence: 0 };
            if (cls === 'leader') {
                state.buffs.luck = 10;
                state.buffTurns = 1;
                log('–£–¥–∞—á–∞ —Å—Ç–∞—Ä–æ—Å—Ç—ã: +10 –∫ —É–¥–∞—á–µ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥.', 'info');
            } else if (cls === 'nerd') {
                state.enemyDebuff = 2;
                state.buffTurns = 0;
                log('–°–∫–∞–Ω —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π: –∑–∞—â–∏—Ç–∞ –≤—Ä–∞–≥–∞ -2 –Ω–∞ —Ö–æ–¥.', 'info');
            } else if (cls === 'vibe') {
                state.buffs.intelligence = 10;
                state.buffTurns = 1;
                log('–ö–æ–¥ —Ä–∞–∑—É–º–∞: +10 –∫ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥.', 'info');
            }
            state.abilityCooldown = 3;
            updateAbilityButton();
            saveToStorage();
            updateBattleUI();
        }

        function maybeLevelUp() {
            while (state.xp >= 100) {
                state.xp -= 100;
                state.level += 1;
                // +1 –∫–æ –≤—Å–µ–º
                statList.forEach(({ key }) => {
                    if (state.stats[key].base !== null) state.stats[key].base += 1;
                });
                renderStatsValues();
                openLevelModal();
            }
        }

        function openLevelModal() {
            elements.levelChoices.innerHTML = '';
            statList.forEach(({ key, label }) => {
                const btn = document.createElement('button');
                btn.className = 'choice';
                btn.dataset.stat = key;
                btn.textContent = `${label} +2`;
                btn.addEventListener('click', () => {
                    elements.levelChoices.querySelectorAll('.choice').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    elements.confirmLevelUp.disabled = false;
                    elements.confirmLevelUp.dataset.stat = key;
                });
                elements.levelChoices.appendChild(btn);
            });
            elements.levelModal.hidden = false;
        }

        function confirmLevelUp() {
            const stat = elements.confirmLevelUp.dataset.stat;
            if (!stat) return;
            if (state.stats[stat].base !== null) state.stats[stat].base += 2;
            elements.levelModal.hidden = true;
            renderStatsValues();
            const derived = deriveCombat();
            state.playerHp = derived.maxHp;
            log(`–£—Ä–æ–≤–µ–Ω—å ${state.level}: +2 –∫ ${stat}`, 'victory');
            saveToStorage();
        }

        // ---------- Events ----------
        function bindEvents() {
            document.getElementById('charClass').addEventListener('change', (e) => {
                state.classId = e.target.value;
                setClassDetails();
                renderStatsValues();
                saveToStorage();
            });
            elements.rollAll.addEventListener('click', rollAll);
            elements.saveCharacter.addEventListener('click', () => { saveToStorage(); log('–õ–∏—Å—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω', 'info'); });
            elements.freeRoll.addEventListener('click', () => {
                state.freeRoll = rollD20();
                elements.freeRollValue.textContent = state.freeRoll;
                elements.freeRollValue.style.animation = 'dice-roll .5s ease';
                setTimeout(() => elements.freeRollValue.style.animation = '', 500);
                saveToStorage();
            });
            elements.assignRoll.addEventListener('click', assignFree);
            elements.statsGrid.addEventListener('click', (e) => {
                const btn = e.target.closest('.mini-roll');
                if (btn) rollStat(btn.dataset.roll);
            });
            elements.battleStart.addEventListener('click', () => { ensureEnemy(); updateBattleUI(); log('–ë–æ–π –Ω–∞—á–∞—Ç.', 'info'); });
            elements.battleAttack.addEventListener('click', playerAttack);
            elements.useAbility.addEventListener('click', useAbility);
            elements.battleRest.addEventListener('click', restPlayer);
            elements.nextLabBtn.addEventListener('click', () => { elements.victoryModal.hidden = true; ensureEnemy(); updateBattleUI(); });
            elements.confirmLevelUp.addEventListener('click', confirmLevelUp);
            elements.themeToggle.addEventListener('click', toggleTheme);
            elements.battleLog.addEventListener('dblclick', () => { elements.battleLog.innerHTML = ''; });
            elements.newCharacterBtn.addEventListener('click', () => { openResetModal(false); });
            elements.confirmReset.addEventListener('click', () => { resetCharacter(); });
            elements.cancelReset.addEventListener('click', () => { elements.resetModal.hidden = true; });
            elements.openResetBtn?.addEventListener('click', () => { elements.defeatModal.hidden = true; openResetModal(true); });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && document.activeElement.tagName === 'INPUT') {
                    saveToStorage();
                }
            });
        }

        function toggleTheme() {
            const next = document.body.classList.contains('dark') ? 'light' : 'dark';
            document.body.classList.toggle('dark', next === 'dark');
            localStorage.setItem(THEME_KEY, next);
            elements.themeToggle.innerHTML = next === 'dark' ? '<i class="fa-regular fa-sun"></i> –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞' : '<i class="fa-regular fa-moon"></i> –¢—ë–º–Ω–∞—è —Ç–µ–º–∞';
        }

        function initTheme() {
            const saved = localStorage.getItem(THEME_KEY);
            if (saved === 'dark') document.body.classList.add('dark');
            elements.themeToggle.innerHTML = document.body.classList.contains('dark') ? '<i class="fa-regular fa-sun"></i> –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞' : '<i class="fa-regular fa-moon"></i> –¢—ë–º–Ω–∞—è —Ç–µ–º–∞';
        }

        // ---------- Init ----------
        function init() {
            renderStatCards();
            loadFromStorage();
            setClassDetails();
            renderStatsValues();
            initTheme();
            bindEvents();
            updateBattleUI();
            log('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ª–∏—Å—Ç –∏ –Ω–∞—á–Ω–∏—Ç–µ –±–æ–π.', 'info');
        }

        init();
    })();
</script>
</body>
</html>
